"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTestRunner = void 0;
/* eslint-disable no-inner-declarations */
const test_runner_core_1 = require("@web/test-runner-core");
const chalk_1 = __importDefault(require("chalk"));
const mergeConfigs_1 = require("./config/mergeConfigs");
const parseConfig_1 = require("./config/parseConfig");
const readCliArgs_1 = require("./config/readCliArgs");
const readFileConfig_1 = require("./config/readFileConfig");
const TestRunnerStartError_1 = require("./TestRunnerStartError");
/**
 * Starts the test runner.
 */
async function startTestRunner(options = {}) {
    const { config: extraConfig, readCliArgs: readCliArgsFlag = true, readFileConfig: readFileConfigFlag = true, configName, autoExitProcess = true, argv = process.argv, } = options;
    try {
        const cliArgs = readCliArgsFlag ? readCliArgs_1.readCliArgs({ argv }) : {};
        const rawConfig = readFileConfigFlag
            ? await readFileConfig_1.readFileConfig({ configName, configPath: cliArgs.config })
            : {};
        const mergedConfig = mergeConfigs_1.mergeConfigs(extraConfig, rawConfig);
        const { config, groupConfigs } = await parseConfig_1.parseConfig(mergedConfig, cliArgs);
        const runner = new test_runner_core_1.TestRunner(config, groupConfigs);
        const cli = new test_runner_core_1.TestRunnerCli(config, runner);
        function stop() {
            runner.stop();
        }
        if (autoExitProcess) {
            ['exit', 'SIGINT'].forEach(event => {
                process.on(event, stop);
            });
        }
        if (autoExitProcess) {
            process.on('uncaughtException', error => {
                /* eslint-disable-next-line no-console */
                console.error(error);
                stop();
            });
        }
        runner.on('stopped', passed => {
            if (autoExitProcess) {
                process.exit(passed ? 0 : 1);
            }
        });
        await runner.start();
        cli.start();
        return runner;
    }
    catch (error) {
        if (error instanceof TestRunnerStartError_1.TestRunnerStartError) {
            console.error(`\n${chalk_1.default.red('Error:')} ${error.message}\n`);
        }
        else {
            console.error(error);
        }
        setTimeout(() => {
            // exit after a timeout to allow CLI to flush console output
            process.exit(1);
        }, 0);
    }
}
exports.startTestRunner = startTestRunner;
//# sourceMappingURL=startTestRunner.js.map