"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChromeLauncherPage = void 0;
const test_runner_coverage_v8_1 = require("@web/test-runner-coverage-v8");
class ChromeLauncherPage {
    constructor(config, testFiles, product, puppeteerPage) {
        this.nativeInstrumentationEnabledOnPage = false;
        this.config = config;
        this.testFiles = testFiles;
        this.product = product;
        this.puppeteerPage = puppeteerPage;
    }
    async runSession(url, coverage) {
        var _a;
        if (coverage &&
            ((_a = this.config.coverageConfig) === null || _a === void 0 ? void 0 : _a.nativeInstrumentation) !== false &&
            this.product === 'chromium') {
            if (this.nativeInstrumentationEnabledOnPage) {
                await this.puppeteerPage.coverage.stopJSCoverage();
            }
            this.nativeInstrumentationEnabledOnPage = true;
            await this.puppeteerPage.coverage.startJSCoverage();
        }
        await this.puppeteerPage.setViewport({ height: 600, width: 800 });
        await this.puppeteerPage.goto(url);
    }
    async stopSession() {
        const testCoverage = await this.collectTestCoverage(this.config, this.testFiles);
        // navigate to an empty page to kill any running code on the page, stopping timers and
        // breaking a potential endless reload loop
        await this.puppeteerPage.goto('about:blank');
        return { testCoverage };
    }
    async collectTestCoverage(config, testFiles) {
        var _a, _b;
        const userAgentPromise = this.puppeteerPage
            .browser()
            .userAgent()
            .catch(() => undefined);
        try {
            const coverageFromBrowser = await this.puppeteerPage.evaluate(() => window.__coverage__);
            if (coverageFromBrowser) {
                // coverage was generated by JS, return that
                return coverageFromBrowser;
            }
        }
        catch (error) {
            // evaluate throws when the test navigates in the browser
        }
        if (((_a = config.coverageConfig) === null || _a === void 0 ? void 0 : _a.nativeInstrumentation) === false) {
            throw new Error('Coverage is enabled with nativeInstrumentation disabled. ' +
                'Expected coverage provided in the browser as a global __coverage__ variable.' +
                'Use a plugin like babel-plugin-istanbul to generate the coverage, or enable native instrumentation.');
        }
        if (!this.nativeInstrumentationEnabledOnPage) {
            return undefined;
        }
        // get native coverage from puppeteer
        // TODO: this is using a private puppeteer API to grab v8 code coverage, this can be removed
        // when https://github.com/puppeteer/puppeteer/issues/2136 is resolved
        const response = (await this.puppeteerPage._client.send('Profiler.takePreciseCoverage'));
        const v8Coverage = response.result
            // remove puppeteer specific scripts
            .filter(r => r.url && r.url !== '__puppeteer_evaluation_script__');
        const userAgent = await userAgentPromise;
        await ((_b = this.puppeteerPage.coverage) === null || _b === void 0 ? void 0 : _b.stopJSCoverage());
        this.nativeInstrumentationEnabledOnPage = false;
        return test_runner_coverage_v8_1.v8ToIstanbul(config, testFiles, v8Coverage, userAgent);
    }
}
exports.ChromeLauncherPage = ChromeLauncherPage;
//# sourceMappingURL=ChromeLauncherPage.js.map